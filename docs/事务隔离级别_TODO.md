# 事务隔离级别

因为人们为了提高事务执行的效率，引入了各种方法以允许多个事务可以同时并发执行，但是数据只有 1 份，于是在事务执行期间，出现各种诡异的现象。比如：

1. 事务开始后，第一次读数据A，发现没有，但过了一会儿再读，居然又有了。
2. 事务开始后，第一次读数据A，得到的是10， 单过了一会儿再读， 发现编程20了。
3. ......

这些现象都是因为不同的并发策略导致的。之前，我们大致总结分析了下几种常见并发控制算法。现在我们直观看一下，有次导致的一种异常现象，人们根据其严重程度，划分了级别，也就是事务隔离级别。

<br>

## 1. 隔离级别的定义
----
<br>

需要注意的是，这些现象是在事务期间，但是当事务提交后，并不会影响最终落地的数据的正确性。事务隔离级别也被称为 read phenomena， 隔离级别从第到高依次为：

1. read uncommitted： 
   
   这是最不严谨的隔离级别，也就是一个事务可能读到其他事务还没有提交的数据，问题是其他事务可能回滚。那你读的这个也就是无效数据了，即 dirty read。

   需要注意的是，如果上层程序中以脏数据去作为判断依据，去更新表里的其他数据，可能造成业务逻辑上的错误，因为如果脏数据回滚了，这个判断依据就是错误的。

2. read committed：

    可以保证读到的数据都是已经提交的数据，注意虽然是已经提交的，但是可能不是最新的。也就是在你读出来之后，别人又提交了。完事儿你在读的话，就跟上次读出来的数据不一样了。

3. repeatable read:

    在 read committed 里边，每次读的数据虽然是提交的，可是不保证每次读都一样。这个级别在次基础上，除了保证读出来的数据是已经提交的，还保证每次读的都一样。当然了，后边读的数据可能就不是最新的了。

    但是可能导致幻读，也就是用户第一次读取某个范围的数据，等第二次读的时候，里边可能多了数据。多的这些数据就是别人新插入的数据。

    MySQL 的默认事务隔离级别就是这个

4. serializable：

    这种级别下，要求结果跟多个事务，挨个串行执行是一样的。也就不会有幻读了。

<br>

## 2. 每种隔离级别的例子。
----
<br>

 TODO：
 脏数据回滚的问题，重复读回滚的问题。


# 参考资料
----

1. [Deeply understand Isolation levels and Read phenomena in MySQL & PostgreSQL](https://dev.to/techschoolguru/understand-isolation-levels-read-phenomena-in-mysql-postgres-c2e#4-read-phenomena)